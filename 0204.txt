시간 복잡도 = T(n)
빅 O -> T(n) = n^2+2n이면 O(n^2)로 표현 가능하다.

1. O(n) :선형 빅 O : 데이터가 많아지면 시간도 늘어가는 구조
2. O(n^2):데이터가 늘어나면 그 제곱 만큼 늘어날 것
3. O(logn) : 가장 이상적인 형태, 로그함수 그래프를 따라감 -> 데이터가 많아도 T의 상승폭이 크지않음
4. O(nlogn) : 데이터가 2배 늘어나면 시간은 2배보다 조금 더 늘어남
5. O(1) : 딱 한번의 계산만 함
6. O(2*n) : 지수함수의 그래프를 따라감: 데이터가 늘면 시간은 훨씬 큰 폭으로 늘어남 -> 지양해야 할 빅오
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(2*n)

탐색 알고리즘 2가지 
1. 순차탐색 : 순서대로 있는지 없는지 확인하는 구조 -> O(n)
2. 이진 탐색(binary search) : O(logn)


재귀:
f(n) = f(n-1)+a 형태에서 사용 -> 특정 함수를 계속 반복할 때 사용
ㄴ f(n)을 하기 위해서 f(n-1)을, f(n-1)을 하기 위해서 f(n-2)를 사용할 때 재귀를 사용한다.
ㄴㄴ 재귀를 사용하는 상황을 이해하고, 과감하게 재귀처리하기 ->재귀가 이뤄지는 과정을 세세하게 코딩x
ㄴㄴ 재귀로 코딩을 하면 출력 부분이 나오는 예외 처리되는 조건문에서만 출력이 될 것임.
move 1 from a to b
move 2 from a to c
move 1 from b to c
move 3 from a to b ... -> 예외문에서만 출력을 시켰지만 실제로는 n -> n-1 -> n-2 -> ... -> 1로 진행 됐을것임.
두 가지 구성 -> 함수 처리&실행 종료 구문 -> f(2)나 f(1)에서 멈추기 위한 조건문